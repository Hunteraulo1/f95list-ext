var background=function(){"use strict";var R,B,D,N;function J(a){return a==null||typeof a=="function"?{main:a}:a}const j=((B=(R=globalThis.browser)==null?void 0:R.runtime)==null?void 0:B.id)==null?globalThis.chrome:globalThis.browser;var P=Object.prototype.hasOwnProperty;function O(a,e){var n,s;if(a===e)return!0;if(a&&e&&(n=a.constructor)===e.constructor){if(n===Date)return a.getTime()===e.getTime();if(n===RegExp)return a.toString()===e.toString();if(n===Array){if((s=a.length)===e.length)for(;s--&&O(a[s],e[s]););return s===-1}if(!n||typeof a=="object"){s=0;for(n in a)if(P.call(a,n)&&++s&&!P.call(e,n)||!(n in e)||!O(a[n],e[n]))return!1;return Object.keys(e).length===s}}return a!==a&&e!==e}const X=new Error("request for lock canceled");var Y=function(a,e,n,s){function d(u){return u instanceof n?u:new n(function(h){h(u)})}return new(n||(n=Promise))(function(u,h){function v(g){try{I(s.next(g))}catch(p){h(p)}}function K(g){try{I(s.throw(g))}catch(p){h(p)}}function I(g){g.done?u(g.value):d(g.value).then(v,K)}I((s=s.apply(a,e||[])).next())})};class Z{constructor(e,n=X){this._value=e,this._cancelError=n,this._queue=[],this._weightedWaiters=[]}acquire(e=1,n=0){if(e<=0)throw new Error(`invalid weight ${e}: must be positive`);return new Promise((s,d)=>{const u={resolve:s,reject:d,weight:e,priority:n},h=U(this._queue,v=>n<=v.priority);h===-1&&e<=this._value?this._dispatchItem(u):this._queue.splice(h+1,0,u)})}runExclusive(e){return Y(this,arguments,void 0,function*(n,s=1,d=0){const[u,h]=yield this.acquire(s,d);try{return yield n(u)}finally{h()}})}waitForUnlock(e=1,n=0){if(e<=0)throw new Error(`invalid weight ${e}: must be positive`);return this._couldLockImmediately(e,n)?Promise.resolve():new Promise(s=>{this._weightedWaiters[e-1]||(this._weightedWaiters[e-1]=[]),G(this._weightedWaiters[e-1],{resolve:s,priority:n})})}isLocked(){return this._value<=0}getValue(){return this._value}setValue(e){this._value=e,this._dispatchQueue()}release(e=1){if(e<=0)throw new Error(`invalid weight ${e}: must be positive`);this._value+=e,this._dispatchQueue()}cancel(){this._queue.forEach(e=>e.reject(this._cancelError)),this._queue=[]}_dispatchQueue(){for(this._drainUnlockWaiters();this._queue.length>0&&this._queue[0].weight<=this._value;)this._dispatchItem(this._queue.shift()),this._drainUnlockWaiters()}_dispatchItem(e){const n=this._value;this._value-=e.weight,e.resolve([n,this._newReleaser(e.weight)])}_newReleaser(e){let n=!1;return()=>{n||(n=!0,this.release(e))}}_drainUnlockWaiters(){if(this._queue.length===0)for(let e=this._value;e>0;e--){const n=this._weightedWaiters[e-1];n&&(n.forEach(s=>s.resolve()),this._weightedWaiters[e-1]=[])}else{const e=this._queue[0].priority;for(let n=this._value;n>0;n--){const s=this._weightedWaiters[n-1];if(!s)continue;const d=s.findIndex(u=>u.priority<=e);(d===-1?s:s.splice(0,d)).forEach(u=>u.resolve())}}}_couldLockImmediately(e,n){return(this._queue.length===0||this._queue[0].priority<n)&&e<=this._value}}function G(a,e){const n=U(a,s=>e.priority<=s.priority);a.splice(n+1,0,e)}function U(a,e){for(let n=a.length-1;n>=0;n--)if(e(a[n]))return n;return-1}var ee=function(a,e,n,s){function d(u){return u instanceof n?u:new n(function(h){h(u)})}return new(n||(n=Promise))(function(u,h){function v(g){try{I(s.next(g))}catch(p){h(p)}}function K(g){try{I(s.throw(g))}catch(p){h(p)}}function I(g){g.done?u(g.value):d(g.value).then(v,K)}I((s=s.apply(a,e||[])).next())})};class te{constructor(e){this._semaphore=new Z(1,e)}acquire(){return ee(this,arguments,void 0,function*(e=0){const[,n]=yield this._semaphore.acquire(1,e);return n})}runExclusive(e,n=0){return this._semaphore.runExclusive(()=>e(),1,n)}isLocked(){return this._semaphore.isLocked()}waitForUnlock(e=0){return this._semaphore.waitForUnlock(1,e)}release(){this._semaphore.isLocked()&&this._semaphore.release()}cancel(){return this._semaphore.cancel()}}const q=((N=(D=globalThis.browser)==null?void 0:D.runtime)==null?void 0:N.id)==null?globalThis.chrome:globalThis.browser,b=re();function re(){const a={local:T("local"),session:T("session"),sync:T("sync"),managed:T("managed")},e=i=>{const r=a[i];if(r==null){const t=Object.keys(a).join(", ");throw Error(`Invalid area "${i}". Options: ${t}`)}return r},n=i=>{const r=i.indexOf(":"),t=i.substring(0,r),o=i.substring(r+1);if(o==null)throw Error(`Storage key should be in the form of "area:key", but received "${i}"`);return{driverArea:t,driverKey:o,driver:e(t)}},s=i=>i+"$",d=(i,r)=>{const t={...i};return Object.entries(r).forEach(([o,c])=>{c==null?delete t[o]:t[o]=c}),t},u=(i,r)=>i??r??null,h=i=>typeof i=="object"&&!Array.isArray(i)?i:{},v=async(i,r,t)=>{const o=await i.getItem(r);return u(o,(t==null?void 0:t.fallback)??(t==null?void 0:t.defaultValue))},K=async(i,r)=>{const t=s(r),o=await i.getItem(t);return h(o)},I=async(i,r,t)=>{await i.setItem(r,t??null)},g=async(i,r,t)=>{const o=s(r),c=h(await i.getItem(o));await i.setItem(o,d(c,t))},p=async(i,r,t)=>{if(await i.removeItem(r),t!=null&&t.removeMeta){const o=s(r);await i.removeItem(o)}},Q=async(i,r,t)=>{const o=s(r);if(t==null)await i.removeItem(o);else{const c=h(await i.getItem(o));[t].flat().forEach(l=>delete c[l]),await i.setItem(o,c)}},z=(i,r,t)=>i.watch(r,t);return{getItem:async(i,r)=>{const{driver:t,driverKey:o}=n(i);return await v(t,o,r)},getItems:async i=>{const r=new Map,t=new Map,o=[];i.forEach(l=>{let f,w;typeof l=="string"?f=l:"getValue"in l?(f=l.key,w={fallback:l.fallback}):(f=l.key,w=l.options),o.push(f);const{driverArea:x,driverKey:y}=n(f),_=r.get(x)??[];r.set(x,_.concat(y)),t.set(f,w)});const c=new Map;return await Promise.all(Array.from(r.entries()).map(async([l,f])=>{(await a[l].getItems(f)).forEach(x=>{const y=`${l}:${x.key}`,_=t.get(y),m=u(x.value,(_==null?void 0:_.fallback)??(_==null?void 0:_.defaultValue));c.set(y,m)})})),o.map(l=>({key:l,value:c.get(l)}))},getMeta:async i=>{const{driver:r,driverKey:t}=n(i);return await K(r,t)},getMetas:async i=>{const r=i.map(c=>{const l=typeof c=="string"?c:c.key,{driverArea:f,driverKey:w}=n(l);return{key:l,driverArea:f,driverKey:w,driverMetaKey:s(w)}}),t=r.reduce((c,l)=>{var f;return c[f=l.driverArea]??(c[f]=[]),c[l.driverArea].push(l),c},{}),o={};return await Promise.all(Object.entries(t).map(async([c,l])=>{const f=await q.storage[c].get(l.map(w=>w.driverMetaKey));l.forEach(w=>{o[w.key]=f[w.driverMetaKey]??{}})})),r.map(c=>({key:c.key,meta:o[c.key]}))},setItem:async(i,r)=>{const{driver:t,driverKey:o}=n(i);await I(t,o,r)},setItems:async i=>{const r={};i.forEach(t=>{const{driverArea:o,driverKey:c}=n("key"in t?t.key:t.item.key);r[o]??(r[o]=[]),r[o].push({key:c,value:t.value})}),await Promise.all(Object.entries(r).map(async([t,o])=>{await e(t).setItems(o)}))},setMeta:async(i,r)=>{const{driver:t,driverKey:o}=n(i);await g(t,o,r)},setMetas:async i=>{const r={};i.forEach(t=>{const{driverArea:o,driverKey:c}=n("key"in t?t.key:t.item.key);r[o]??(r[o]=[]),r[o].push({key:c,properties:t.meta})}),await Promise.all(Object.entries(r).map(async([t,o])=>{const c=e(t),l=o.map(({key:y})=>s(y));console.log(t,l);const f=await c.getItems(l),w=Object.fromEntries(f.map(({key:y,value:_})=>[y,h(_)])),x=o.map(({key:y,properties:_})=>{const m=s(y);return{key:m,value:d(w[m]??{},_)}});await c.setItems(x)}))},removeItem:async(i,r)=>{const{driver:t,driverKey:o}=n(i);await p(t,o,r)},removeItems:async i=>{const r={};i.forEach(t=>{let o,c;typeof t=="string"?o=t:"getValue"in t?o=t.key:"item"in t?(o=t.item.key,c=t.options):(o=t.key,c=t.options);const{driverArea:l,driverKey:f}=n(o);r[l]??(r[l]=[]),r[l].push(f),c!=null&&c.removeMeta&&r[l].push(s(f))}),await Promise.all(Object.entries(r).map(async([t,o])=>{await e(t).removeItems(o)}))},clear:async i=>{await e(i).clear()},removeMeta:async(i,r)=>{const{driver:t,driverKey:o}=n(i);await Q(t,o,r)},snapshot:async(i,r)=>{var c;const o=await e(i).snapshot();return(c=r==null?void 0:r.excludeKeys)==null||c.forEach(l=>{delete o[l],delete o[s(l)]}),o},restoreSnapshot:async(i,r)=>{await e(i).restoreSnapshot(r)},watch:(i,r)=>{const{driver:t,driverKey:o}=n(i);return z(t,o,r)},unwatch(){Object.values(a).forEach(i=>{i.unwatch()})},defineItem:(i,r)=>{const{driver:t,driverKey:o}=n(i),{version:c=1,migrations:l={}}=r??{};if(c<1)throw Error("Storage item version cannot be less than 1. Initial versions should be set to 1, not 0.");const f=async()=>{var H;const m=s(o),[{value:E},{value:k}]=await t.getItems([o,m]);if(E==null)return;const V=(k==null?void 0:k.v)??1;if(V>c)throw Error(`Version downgrade detected (v${V} -> v${c}) for "${i}"`);console.debug(`[@wxt-dev/storage] Running storage migration for ${i}: v${V} -> v${c}`);const ce=Array.from({length:c-V},(W,F)=>V+F+1);let $=E;for(const W of ce)try{$=await((H=l==null?void 0:l[W])==null?void 0:H.call(l,$))??$}catch(F){throw Error(`v${W} migration failed for "${i}"`,{cause:F})}await t.setItems([{key:o,value:$},{key:m,value:{...k,v:c}}]),console.debug(`[@wxt-dev/storage] Storage migration completed for ${i} v${c}`,{migratedValue:$})},w=(r==null?void 0:r.migrations)==null?Promise.resolve():f().catch(m=>{console.error(`[@wxt-dev/storage] Migration failed for ${i}`,m)}),x=new te,y=()=>(r==null?void 0:r.fallback)??(r==null?void 0:r.defaultValue)??null,_=()=>x.runExclusive(async()=>{const m=await t.getItem(o);if(m!=null||(r==null?void 0:r.init)==null)return m;const E=await r.init();return await t.setItem(o,E),E});return w.then(_),{key:i,get defaultValue(){return y()},get fallback(){return y()},getValue:async()=>(await w,r!=null&&r.init?await _():await v(t,o,r)),getMeta:async()=>(await w,await K(t,o)),setValue:async m=>(await w,await I(t,o,m)),setMeta:async m=>(await w,await g(t,o,m)),removeValue:async m=>(await w,await p(t,o,m)),removeMeta:async m=>(await w,await Q(t,o,m)),watch:m=>z(t,o,(E,k)=>m(E??y(),k??y())),migrate:f}}}}function T(a){const e=()=>{if(q.runtime==null)throw Error(["'wxt/storage' must be loaded in a web extension environment",`
 - If thrown during a build, see https://github.com/wxt-dev/wxt/issues/371`,` - If thrown during tests, mock 'wxt/browser' correctly. See https://wxt.dev/guide/go-further/testing.html
`].join(`
`));if(q.storage==null)throw Error("You must add the 'storage' permission to your manifest to use 'wxt/storage'");const s=q.storage[a];if(s==null)throw Error(`"browser.storage.${a}" is undefined`);return s},n=new Set;return{getItem:async s=>(await e().get(s))[s],getItems:async s=>{const d=await e().get(s);return s.map(u=>({key:u,value:d[u]??null}))},setItem:async(s,d)=>{d==null?await e().remove(s):await e().set({[s]:d})},setItems:async s=>{const d=s.reduce((u,{key:h,value:v})=>(u[h]=v,u),{});await e().set(d)},removeItem:async s=>{await e().remove(s)},removeItems:async s=>{await e().remove(s)},clear:async()=>{await e().clear()},snapshot:async()=>await e().get(),restoreSnapshot:async s=>{await e().set(s)},watch(s,d){const u=h=>{const v=h[s];v!=null&&(O(v.newValue,v.oldValue)||d(v.newValue??null,v.oldValue??null))};return e().onChanged.addListener(u),n.add(u),()=>{e().onChanged.removeListener(u),n.delete(u)}},unwatch(){n.forEach(s=>{e().onChanged.removeListener(s)}),n.clear()}}}const ae=J(async()=>{const a=await C();a&&await A(a)}),A=async a=>{if(!a||a.updates.length===0)throw new Error("data not defined or empty");const e=a.updates,n=await b.getItem("local:f95list_ext_badge")??[];let s=0;e==null||e.every(u=>n[0]&&u.date<n[0].date?!1:(s+=u.names.length,!0)),n.map(u=>{s-=u.names.length});const d=j.browserAction??j.action;d.setBadgeText({text:s===0?null:s.toString()}),d.setBadgeBackgroundColor({color:"#CC0000"})},ne=async a=>{if(!a||a.updates.length===0)throw new Error("data not defined or empty");try{const e=[a.updates[0]];a.updates[0].date===a.updates[1].date&&e.push(a.updates[1]),await b.setItem("local:f95list_ext_badge",e),await A(a)}catch(e){console.error(e)}};let M=!1;const se=a=>new Promise(e=>setTimeout(e,a)),C=async()=>{for(;M;)await se(1e3);let a=await b.getItem("local:f95list_ext_data");if(M)return null;M=!0;const e=new Date().getTime(),n=await b.getItem("local:f95list_ext_time")??0;if(a&&e<n)return M=!1,a;if(a=await ie(),!a)throw new Error("data not found");return await b.setItem("local:f95list_ext_time",e+1e3*60*60*2),await b.setItem("local:f95list_ext_data",a),await A(a),M=!1,a};j.runtime.onMessage.addListener((a,e,n)=>(console.info(a),(async()=>{const s=await C();if(console.log("🚀 ~ data:",s),!s||typeof a!="string")return console.error("data not found"),!1;switch(a){case"f95list-script":{const d=await b.getItem("local:f95list_ext_integrate");if(console.log("🚀 ~ integrate:",d),d===void 0)b.setItem("local:f95list_ext_integrate",!0);else if(!d)break;n(s.games);break}case"f95list-ext":n(s);break;case"f95list-badge":await ne(s);break;case(a.startsWith("f95list-integrate")?a:"f95list-integrate"):await b.setItem("local:f95list_ext_integrate",a.endsWith("true"));break}})(),!0));const ie=async()=>{try{console.info("🚀 ~ query: ~ fetch");const e=await(await fetch("https://script.google.com/macros/s/AKfycbybvrFy6B2L7rkLWJnrwRHhP0F6Sv0uk6V9zUTZibwEzUjKXf-abOK_N6jUhqFPs9US/exec")).json();if(!(e!=null&&e.data))throw new Error("fetch not data");return e.data}catch(a){console.error(a),await b.setItem("local:f95list_ext_time",0),M=!1}};function le(){}function S(a,...e){}const oe={debug:(...a)=>S(console.debug,...a),log:(...a)=>S(console.log,...a),warn:(...a)=>S(console.warn,...a),error:(...a)=>S(console.error,...a)};let L;try{L=ae.main(),L instanceof Promise&&console.warn("The background's main() function return a promise, but it must be synchronous")}catch(a){throw oe.error("The background crashed on startup!"),a}return L}();
background;
